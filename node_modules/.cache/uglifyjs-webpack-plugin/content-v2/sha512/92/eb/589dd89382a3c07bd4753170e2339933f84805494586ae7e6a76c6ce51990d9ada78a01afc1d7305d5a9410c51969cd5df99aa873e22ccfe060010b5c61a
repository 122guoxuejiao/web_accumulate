{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{168:function(e,t,n){\"use strict\";n.r(t);var r=n(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"content\"},[n(\"h3\",{attrs:{id:\"watcher函数\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#watcher函数\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Watcher函数:\")]),e._v(\" \"),n(\"p\",[e._v(\"这是实现思路中的第三步，因为下方数据监听器\"),n(\"code\",[e._v(\"_observer()\")]),e._v(\"需要用到Watcher函数，所以这里就先讲了。\")]),e._v(\" \"),n(\"p\",[e._v(\"像实现思路中所说的，这里起到了连接Observer和Compile的作用：\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[n(\"p\",[n(\"strong\",[e._v(\"在模板编译_compile()阶段发布订阅\")])])]),e._v(\" \"),n(\"li\",[n(\"p\",[n(\"strong\",[e._v(\"在赋值操作的时候，更新视图\")])]),e._v(\" \"),n(\"pre\",[n(\"code\",[e._v(\" // new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图\\n function Watcher(el, vm, val, attr) {\\n     this.el = el; // 指令对应的DOM元素\\n     this.vm = vm; // myVue实例\\n     this.val = val; // 指令对应的值 \\n     this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值\\n     this.update(); // 更新视图\\n }\\n Watcher.prototype.update = function () { \\n     this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图\\n }\\n\")])])])]),e._v(\" \"),n(\"p\",[e._v(\"没有看错，代码量就这么多，可能需要把整个代码连接起来，多看几遍才能够理解。\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"实现数据监听器-observer-：\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现数据监听器-observer-：\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 实现数据监听器_observer()：\")]),e._v(\" \"),n(\"p\",[e._v(\"实现思路中的第一步，用\"),n(\"code\",[e._v(\"Object.defineProperty()\")]),e._v(\"遍历data重写所有属性的get set。\")]),e._v(\" \"),n(\"p\",[e._v(\"然后在给对象的某个属性赋值的时候，就会触发set。\")]),e._v(\" \"),n(\"p\",[n(\"strong\",[e._v(\"在set中我们可以监听到数据的变化，然后就可以触发watch更新视图\")]),e._v(\"。\")]),e._v(\" \"),n(\"pre\",[n(\"code\",[e._v(\" myVue.prototype._observer = function (obj) {\\n        var _this = this;\\n        Object.keys(obj).forEach(key => { // 遍历数据\\n            _this._watcherTpl[key] = { // 每个数据的订阅池()\\n                _directives: []\\n            };\\n            var value = obj[key]; // 获取属性值\\n            var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池\\n            Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get\\n                configurable: true,  // 可以删除\\n                enumerable: true, // 可以遍历\\n                get() {\\n                    console.log(`${key}获取值：${value}`);\\n                    return value; // 获取值的时候 直接返回\\n                },\\n                set(newVal) { // 改变值的时候 触发set\\n                    console.log(`${key}更新：${newVal}`);\\n                    if (value !== newVal) {\\n                        value = newVal;\\n                        watcherTpl._directives.forEach((item) => { // 遍历订阅池 \\n                            item.update();\\n                            // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图  \\n                        });\\n                    }\\n                }\\n            })\\n        });\\n    }\\n\")])]),e._v(\" \"),n(\"hr\")])}],!1,null,null,null);a.options.__file=\"极简双向绑定.md\";t.default=a.exports}}]);","extractedComments":[]}